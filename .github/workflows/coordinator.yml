name: Coordinator

on:
  schedule:
    - cron: '*/4 * * * *'  # Every 4 minutes for work prioritization
  workflow_dispatch:
  workflow_dispatch:
    inputs:
      force_priority:
        description: 'Force specific priority task'
        required: false
        type: choice
        options:
          - 'auto'
          - 'critical_bug'
          - 'performance_regression'
          - 'security_vulnerability'
          - 'feature_request'
          - 'technical_debt'

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  JIRA_TOKEN: ${{ secrets.JIRA_TOKEN }}
  JIRA_URL: ${{ secrets.JIRA_URL }}

jobs:
  # Primary coordinator job - analyzes and dispatches work
  coordinate-work:
    name: Coordinate Next Priority Work
    runs-on: ubuntu-latest
    outputs:
      priority_task: ${{ steps.analyze.outputs.priority_task }}
      task_type: ${{ steps.analyze.outputs.task_type }}
      agent_personas: ${{ steps.analyze.outputs.agent_personas }}
      estimated_duration: ${{ steps.analyze.outputs.estimated_duration }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install coordinator dependencies
        run: |
          pip install jira requests pyyaml

      - name: Analyze repository state and prioritize work
        id: analyze
        run: |
          python << 'EOF'
          import os
          import json
          import requests
          import subprocess
          from datetime import datetime, timedelta

          def get_github_issues():
              """Get open GitHub issues with priority labels."""
              headers = {'Authorization': f'token {os.environ["GITHUB_TOKEN"]}'}
              repo = os.environ.get('GITHUB_REPOSITORY', 'owner/repo')

              try:
                  response = requests.get(
                      f'https://api.github.com/repos/{repo}/issues',
                      headers=headers,
                      params={'state': 'open', 'per_page': 50}
                  )
                  return response.json() if response.status_code == 200 else []
              except:
                  return []

          def get_recent_failures():
              """Check recent workflow failures."""
              try:
                  result = subprocess.run([
                      'gh', 'run', 'list', '--limit', '10', '--json', 'conclusion,name,createdAt'
                  ], capture_output=True, text=True)

                  if result.returncode == 0:
                      runs = json.loads(result.stdout)
                      failures = [r for r in runs if r['conclusion'] == 'failure']
                      return failures
              except:
                  pass
              return []

          def analyze_code_quality():
              """Analyze code quality metrics."""
              try:
                  # Check test coverage
                  coverage_result = subprocess.run([
                      'python', '-c',
                      'import coverage; cov = coverage.Coverage(); cov.load(); print(cov.report())'
                  ], capture_output=True, text=True)

                  # Check for TODO/FIXME comments
                  todo_result = subprocess.run([
                      'grep', '-r', '-n', 'TODO\|FIXME\|XXX', 'src/', '--include=*.py'
                  ], capture_output=True, text=True)

                  return {
                      'coverage_low': 'FAIL' in coverage_result.stdout,
                      'todo_count': len(todo_result.stdout.splitlines()) if todo_result.stdout else 0
                  }
              except:
                  return {'coverage_low': False, 'todo_count': 0}

          def prioritize_work():
              """Determine the next most important work item."""
              force_priority = os.environ.get('INPUT_FORCE_PRIORITY', 'auto')

              if force_priority != 'auto':
                  return {
                      'priority_task': force_priority,
                      'task_type': 'forced',
                      'agent_personas': get_agent_personas(force_priority),
                      'estimated_duration': '15-30 minutes'
                  }

              # Analyze current state
              issues = get_github_issues()
              failures = get_recent_failures()
              quality = analyze_code_quality()

              # Priority decision matrix
              if failures:
                  return {
                      'priority_task': 'fix_failing_workflows',
                      'task_type': 'critical_bug',
                      'agent_personas': ['debugging-agent', 'ci-cd-agent'],
                      'estimated_duration': '10-15 minutes'
                  }

              if quality['coverage_low']:
                  return {
                      'priority_task': 'improve_test_coverage',
                      'task_type': 'technical_debt',
                      'agent_personas': ['testing-agent', 'tdd-agent'],
                      'estimated_duration': '20-30 minutes'
                  }

              # Check for critical issues
              critical_issues = [i for i in issues if any(
                  label['name'] in ['critical', 'bug', 'security']
                  for label in i.get('labels', [])
              )]

              if critical_issues:
                  issue = critical_issues[0]
                  return {
                      'priority_task': f'resolve_issue_{issue["number"]}',
                      'task_type': 'critical_bug',
                      'agent_personas': ['bug-fix-agent', 'testing-agent'],
                      'estimated_duration': '15-25 minutes'
                  }

              # Check for high-priority features
              feature_issues = [i for i in issues if any(
                  label['name'] in ['enhancement', 'feature']
                  for label in i.get('labels', [])
              )]

              if feature_issues:
                  issue = feature_issues[0]
                  return {
                      'priority_task': f'implement_feature_{issue["number"]}',
                      'task_type': 'feature_request',
                      'agent_personas': ['feature-agent', 'testing-agent', 'documentation-agent'],
                      'estimated_duration': '30-45 minutes'
                  }

              # Default: code quality improvement
              return {
                  'priority_task': 'code_quality_improvement',
                  'task_type': 'technical_debt',
                  'agent_personas': ['refactoring-agent', 'linting-agent'],
                  'estimated_duration': '15-20 minutes'
              }

          def get_agent_personas(task_type):
              """Get appropriate agent personas for task type."""
              persona_map = {
                  'critical_bug': ['debugging-agent', 'testing-agent', 'ci-cd-agent'],
                  'performance_regression': ['performance-agent', 'profiling-agent'],
                  'security_vulnerability': ['security-agent', 'audit-agent'],
                  'feature_request': ['feature-agent', 'testing-agent', 'documentation-agent'],
                  'technical_debt': ['refactoring-agent', 'linting-agent', 'testing-agent']
              }
              return persona_map.get(task_type, ['general-agent'])

          # Execute prioritization
          result = prioritize_work()

          # Output results for subsequent jobs
          print(f"::set-output name=priority_task::{result['priority_task']}")
          print(f"::set-output name=task_type::{result['task_type']}")
          print(f"::set-output name=agent_personas::{','.join(result['agent_personas'])}")
          print(f"::set-output name=estimated_duration::{result['estimated_duration']}")

          # Create work summary
          summary = f"""
          # 🤖 Coordinator Agent - Work Prioritization

          **Timestamp**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}

          ## 📋 Next Priority Work Item

          | Attribute | Value |
          |-----------|-------|
          | **Task** | {result['priority_task']} |
          | **Type** | {result['task_type']} |
          | **Agent Personas** | {', '.join(result['agent_personas'])} |
          | **Estimated Duration** | {result['estimated_duration']} |

          ## 🎯 Dispatching to Specialized Agents

          The coordinator has analyzed the current repository state and identified the highest priority work item.
          Specialized agent personas will be automatically dispatched to handle this work.
          """

          with open(os.environ['GITHUB_STEP_SUMMARY'], 'w') as f:
              f.write(summary)
          EOF

      - name: Log coordination decision
        run: |
          echo "Coordinator Decision:"
          echo "  Priority Task: ${{ steps.analyze.outputs.priority_task }}"
          echo "  Task Type: ${{ steps.analyze.outputs.task_type }}"
          echo "  Agent Personas: ${{ steps.analyze.outputs.agent_personas }}"
          echo "  Estimated Duration: ${{ steps.analyze.outputs.estimated_duration }}"

  # Dispatch to specialized agent personas based on task type
  dispatch-debugging-agent:
    name: Debugging Agent
    runs-on: ubuntu-latest
    needs: coordinate-work
    if: contains(needs.coordinate-work.outputs.agent_personas, 'debugging-agent')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Execute debugging workflow
        run: |
          echo "🐛 Debugging Agent activated for: ${{ needs.coordinate-work.outputs.priority_task }}"
          # Trigger specific debugging workflow
          gh workflow run rail-1-core-business-logic.yml
          gh workflow run rail-2-infrastructure-services.yml

  dispatch-testing-agent:
    name: Testing Agent
    runs-on: ubuntu-latest
    needs: coordinate-work
    if: contains(needs.coordinate-work.outputs.agent_personas, 'testing-agent')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Execute testing workflow
        run: |
          echo "🧪 Testing Agent activated for: ${{ needs.coordinate-work.outputs.priority_task }}"
          # Trigger comprehensive testing workflows
          gh workflow run parallel-testing-matrix.yml

  dispatch-performance-agent:
    name: Performance Agent
    runs-on: ubuntu-latest
    needs: coordinate-work
    if: contains(needs.coordinate-work.outputs.agent_personas, 'performance-agent')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Execute performance workflow
        run: |
          echo "⚡ Performance Agent activated for: ${{ needs.coordinate-work.outputs.priority_task }}"
          # Trigger performance testing workflow
          gh workflow run parallel-performance-testing.yml

  dispatch-security-agent:
    name: Security Agent
    runs-on: ubuntu-latest
    needs: coordinate-work
    if: contains(needs.coordinate-work.outputs.agent_personas, 'security-agent')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Execute security workflow
        run: |
          echo "🔒 Security Agent activated for: ${{ needs.coordinate-work.outputs.priority_task }}"
          # Trigger security scanning
          gh workflow run ci.yml

  dispatch-feature-agent:
    name: Feature Agent
    runs-on: ubuntu-latest
    needs: coordinate-work
    if: contains(needs.coordinate-work.outputs.agent_personas, 'feature-agent')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Execute feature development workflow
        run: |
          echo "✨ Feature Agent activated for: ${{ needs.coordinate-work.outputs.priority_task }}"
          # Trigger feature development workflow
          gh workflow run rail-3-external-integrations.yml

  # Report coordination results
  report-coordination:
    name: Report Coordination Results
    runs-on: ubuntu-latest
    needs:
      - coordinate-work
      - dispatch-debugging-agent
      - dispatch-testing-agent
      - dispatch-performance-agent
      - dispatch-security-agent
      - dispatch-feature-agent
    if: always()

    steps:
      - name: Generate coordination report
        run: |
          echo "# 📊 Coordination Cycle Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Task Processed**: ${{ needs.coordinate-work.outputs.priority_task }}" >> $GITHUB_STEP_SUMMARY
          echo "**Agents Dispatched**: ${{ needs.coordinate-work.outputs.agent_personas }}" >> $GITHUB_STEP_SUMMARY
          echo "**Execution Status**: Workflows triggered successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Coordination**: In 4 minutes" >> $GITHUB_STEP_SUMMARY